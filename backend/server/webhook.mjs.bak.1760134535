import 'dotenv/config';
import express from 'express';
import bodyParser from 'body-parser';
import { Storage } from '@google-cloud/storage';
import { ethers, BigNumber } from 'ethers';
import { randomInt } from 'crypto';
import { encryptJson } from '../scripts/lib/crypto.mjs';
import { fileURLToPath } from 'url';
import path from 'path';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const {
  POLYGON_MAINNET_RPC_URL: RPC,
  BLOCKCHAIN_PRIVATE_KEY: PK,
  NFT_CONTRACT_ADDRESS: NFT_ADDR,
  GOOGLE_APPLICATION_CREDENTIALS,
  GCS_PROJECT_ID,
  GCS_BUCKET,
  WEBHOOK_API_KEY,
  RECEIPT_AES_KEY,
  NFT_BASE_URI,
  MIN_TIP_GWEI = '35'
} = process.env;

if (!RPC || !PK || !NFT_ADDR || !GCS_PROJECT_ID || !GCS_BUCKET || !WEBHOOK_API_KEY || !RECEIPT_AES_KEY) {
  console.error('Missing required envs. Check RPC/PK/NFT_ADDR/GCS_PROJECT_ID/GCS_BUCKET/WEBHOOK_API_KEY/RECEIPT_AES_KEY');
  process.exit(1);
}

const storage = new Storage({
  projectId: GCS_PROJECT_ID,
  keyFilename: GOOGLE_APPLICATION_CREDENTIALS
});
const bucket = storage.bucket(GCS_BUCKET);

function hexId(n) {
  return BigInt(n).toString(16).padStart(64, '0');
}
function gcsPublicUrl(bucket, p) {
  return `https://storage.googleapis.com/${encodeURIComponent(bucket)}/${encodeURI(p)}`;
}
function gwei(n){ return ethers.utils.parseUnits(String(n), 'gwei'); }



function getMerchantName(req) {
  const b = (req && req.body) ? req.body : {};
  const m = b.merchantName ?? b.merchant ?? b.merchant_name ?? b.vendor ?? b.store ?? '';
  return String(m || '');
}


async function pickMerchantImage(bucket, merchant) {
  const name = merchant || "";
  const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  const prefixMap = {
    "dunkin-donuts": process.env.MERCHANT_PREFIX_DUNKIN || "dunkin",
    "cvs": process.env.MERCHANT_PREFIX_CVS || "cvs",
    "nike": process.env.MERCHANT_PREFIX_NIKE || "nike",
  };
  const prefix = prefixMap[slug] || slug;
  const max = Number(process.env.MERCHANT_MAX_IMAGES || 24);

  const base = `https://storage.googleapis.com/${bucket}/merchants/${slug}/images/`;
  // try manifest first
  const manifest = base + "index.json";
  try {
    const r = await fetch(manifest, { method:"GET" });
    if (r.ok) {
      const arr = await r.json();
      if (Array.isArray(arr) && arr.length) {
        const pick = arr[Math.floor(Math.random()*arr.length)];
        console.log("[picker] manifest choose=", pick);
        return pick;
      }
    }
  } catch {}

  const candidatesForIndex = (nn) => ([
    `${base}${prefix}-${nn}.png`,
    `${base}${slug}-${nn}.png`,
    `${base}${nn}.png`
  ]);

  const found = [];
  for (let i = 1; i <= max; i++) {
    const nn = String(i).padStart(2, "0");
    const tries = candidatesForIndex(nn);
    for (const url of tries) {
      try {
        const r = await fetch(url, { method: "HEAD" });
        if (r.ok) { found.push(url); break; }
      } catch { /* ignore */ }
    }
  }
  if (found.length > 0) {
    const pick = found[Math.floor(Math.random() * found.length)];
    console.log("[picker] merchant=", slug, "prefix=", prefix, "found=", found.length, "choose=", pick);
    return pick;
  }

  // fallback pool
  const fbBase = `https://storage.googleapis.com/${bucket}/images/`;
  const fbMax = Number(process.env.MERCHANT_IMAGES_FALLBACK || 0);
  const fbFound = [];
  for (let i = 1; i <= fbMax; i++) {
    const nn = String(i).padStart(2, "0");
    const url = `${fbBase}fallback-${nn}.png`;
    try {
      const r = await fetch(url, { method: "HEAD" });
      if (r.ok) fbFound.push(url);
    } catch {}
  }
  if (fbFound.length > 0) {
    const pick = fbFound[Math.floor(Math.random() * fbFound.length)];
    console.log("[picker] merchant=", slug, "using fallback found=", fbFound.length, "choose=", pick);
    return pick;
  }

  throw new Error("No images found for merchant or fallback");
}



const app = express();
app.use(bodyParser.json());

app.post('/pos/mint', async (req, res) => {
  try {
    if (req.header('x-api-key') !== WEBHOOK_API_KEY) return res.status(401).json({ ok:false, error:'unauthorized' });

    const {
      tokenId,
      to,
      merchantName = 'Unknown Merchant',
      totalCents,
      items = [],                          // [{desc, qty, unitCents}]
      paymentLast4 = '',
      timestamp = Math.floor(Date.now()/1000)
    } = req.body;

    if (typeof tokenId !== 'number' || !to) {
      return res.status(400).json({ ok:false, error:'tokenId (number) and to (address) required' });
    }

    // 1) choose an image for this merchant
    const imageUrl = await pickMerchantImage(merchantName);

    // 2) build PRIVATE payload and encrypt
    const privateReceipt = {
      merchantName,
      timestamp,
      currency: 'USD',
      items,                // [{desc, qty, unitCents}]
      totalCents,
      payment: { method: 'card', last4: paymentLast4 },
      version: 1
    };
    const enc = encryptJson(privateReceipt, RECEIPT_AES_KEY);

    // 3) upload encrypted private JSON
    const idHex = hexId(tokenId);
    const privatePath = `private/${idHex}.json.enc`;
    await bucket.file(privatePath).save(JSON.stringify(enc), {
      resumable: false,
      contentType: 'application/json'
    });
    const privateUrl = gcsPublicUrl(GCS_BUCKET, privatePath);

    // 4) write PUBLIC metadata (minimal, with pointers)
    const meta = {
      name: `BlockReceipt #${tokenId}`,
      description: 'BlockReceipt: encrypted receipt. Viewable by token owner.',
      image: imageUrl,
      external_url: 'https://www.blockreceipt.ai',
      attributes: [
        { trait_type: 'Merchant', value: merchantName },
        { trait_type: 'Total (USD)', value: (totalCents/100).toFixed(2) },
        { trait_type: 'Timestamp', value: timestamp }
      ],
      encryption: {
        enc_url: privateUrl,
        enc_alg: enc.alg
      }
    };
    const metaPath = `metadata/${idHex}.json`;
    await bucket.file(metaPath).save(JSON.stringify(meta, null, 2), {
      resumable: false,
      contentType: 'application/json'
    });
    const metaUrl = gcsPublicUrl(GCS_BUCKET, metaPath);

    // 5) mint (same fee handling you used)
    const provider = new ethers.providers.JsonRpcProvider(RPC, { chainId: 137, name: 'polygon' });
    const signer   = new ethers.Wallet(PK, provider);
    const abi = ['function mint(address to, uint256 id, uint256 amount, bytes data) external'];
    const nft = new ethers.Contract(NFT_ADDR, abi, signer);

    const fd  = await provider.getFeeData();
    const tip = BigNumber.from(fd.maxPriorityFeePerGas || gwei(2)).lt(gwei(MIN_TIP_GWEI)) ? gwei(MIN_TIP_GWEI) : (fd.maxPriorityFeePerGas || gwei(MIN_TIP_GWEI));
    const max = BigNumber.from(fd.maxFeePerGas || (await provider.getGasPrice())).mul(2).add(tip);

    const tx = await nft.mint(to, tokenId, 1, '0x', {
      gasLimit: 220000,
      maxPriorityFeePerGas: tip,
      maxFeePerGas: max
    });
    const rc = await tx.wait();

    return res.json({
      ok: true,
      tokenId,
      to,
      merchantName,
      metadata: metaUrl,
      image: imageUrl,
      txHash: tx.hash,
      blockNumber: rc.blockNumber
    });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ ok:false, error: e.message || String(e) });
  }
});

const port = Number(process.env.PORT || 3000);
app.listen(port, () => {
  console.log(`POS webhook listening on :${port}`);
});
