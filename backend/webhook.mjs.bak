import 'dotenv/config';
import express from 'express';
import { Storage } from '@google-cloud/storage';
import { ethers, BigNumber } from 'ethers';
import crypto from 'crypto';

const app = express();
app.use(express.json({ limit: '1mb' }));

const {
  WEBHOOK_API_KEY,
  POLYGON_MAINNET_RPC_URL: RPC,
  BLOCKCHAIN_PRIVATE_KEY: PK,
  NFT_CONTRACT_ADDRESS: NFT_ADDR,
  GCS_BUCKET
} = process.env;

const storage = new Storage({ keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS });
const bucket  = storage.bucket(GCS_BUCKET);

const gcsUrl = (b, p) => `https://storage.googleapis.com/${b}/${encodeURI(p)}`;

const pickRandom = async () => {
  const [files] = await bucket.getFiles({ prefix: '' });
  const imgs = files
    .map(f => f.name)
    .filter(n => n.toLowerCase().match(/\.(png|jpg|jpeg|gif|webp)$/));
  if (!imgs.length) throw new Error('No images in bucket root');
  const ix = crypto.randomInt(0, imgs.length);
  return gcsUrl(GCS_BUCKET, imgs[ix]);
};

const hexId = (n) => n.toString(16).padStart(64, '0');

app.post('/pos/mint', async (req, res) => {
  try {
    if (req.headers['x-api-key'] !== WEBHOOK_API_KEY) {
      return res.status(401).json({ error: 'unauthorized' });
    }

    const { tokenId, to, merchantName, totalCents } = req.body;
    if (!tokenId) return res.status(400).json({ error: 'tokenId required' });

    const image = await pickRandom();

    const meta = {
      name: `BlockReceipt #${tokenId}`,
      description: merchantName ? `Receipt from ${merchantName}` : 'BlockReceipt POC',
      image,
      external_url: 'https://www.blockreceipt.ai',
      attributes: [
        { trait_type: 'Merchant', value: merchantName || 'N/A' },
        { trait_type: 'Total (cents)', value: Number.isFinite(totalCents) ? totalCents : 0 }
      ]
    };
    const metaPath = `metadata/${hexId(tokenId)}.json`;
    await bucket.file(metaPath).save(JSON.stringify(meta, null, 2), {
      contentType: 'application/json', resumable: false
    });
    try { await bucket.file(metaPath).makePublic(); } catch {}

    const provider = new ethers.providers.JsonRpcProvider(RPC, { chainId: 137, name: 'polygon' });
    const signer   = new ethers.Wallet(PK, provider);
    const abi = ['function mint(address to, uint256 id, uint256 amount, bytes data) external'];
    const nft = new ethers.Contract(NFT_ADDR, abi, signer);

    const fd  = await provider.getFeeData();
    const gwei = (x)=>ethers.utils.parseUnits(String(x),'gwei');
    const tip  = BigNumber.from(fd.maxPriorityFeePerGas || gwei(2)).lt(gwei(35)) ? gwei(35) : (fd.maxPriorityFeePerGas || gwei(35));
    const max  = BigNumber.from(fd.maxFeePerGas || (await provider.getGasPrice())).mul(2).add(tip);

    const toAddr = to || process.env.CUSTOMER_WALLET_ADDRESS;
    const tx = await nft.mint(toAddr, tokenId, 1, '0x', {
      gasLimit: 220000, maxPriorityFeePerGas: tip, maxFeePerGas: max
    });
    const r = await tx.wait();

    res.json({
      ok: true,
      tokenId,
      to: toAddr,
      metadata: gcsUrl(GCS_BUCKET, metaPath),
      image,
      txHash: r.transactionHash
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: e.message || String(e) });
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`POS webhook listening on :${port}`));
