import 'dotenv/config';
import express from 'express';
import crypto from 'crypto';
import { Storage } from '@google-cloud/storage';
import { ethers, BigNumber } from 'ethers';

const RPC              = process.env.POLYGON_MAINNET_RPC_URL;
const PK               = process.env.BLOCKCHAIN_PRIVATE_KEY;
const NFT_ADDR         = process.env.NFT_CONTRACT_ADDRESS;
const GCS_PROJECT_ID   = process.env.GCS_PROJECT_ID;
const BUCKET           = process.env.GCS_BUCKET;
const API_KEY          = process.env.WEBHOOK_API_KEY;
const RECEIPT_AES_KEY  = process.env.RECEIPT_AES_KEY || null;

if (!RPC || !PK || !NFT_ADDR || !GCS_PROJECT_ID || !BUCKET || !API_KEY) {
  console.error('Missing required envs. Check RPC/PK/NFT_ADDR/GCS_PROJECT_ID/GCS_BUCKET/WEBHOOK_API_KEY');
  process.exit(1);
}

const app = express();
app.use(express.json({ limit: '1mb' }));

const storage = new Storage();
const bucket = storage.bucket(BUCKET);
app.post("/pos/mint", async (req,res)=>{
  try{
    if(req.get("x-api-key")!==API_KEY) return res.status(401).json({ok:false,error:"Unauthorized"});
    const body=req.body||{};
    const tokenId=Number(body.tokenId);
    const to=String(body.to||"").trim();
    const merchantName=body.merchantName||"Unknown Merchant";
    if(!Number.isFinite(tokenId))return res.status(400).json({ok:false,error:"Bad tokenId"});
    if(!to||!to.startsWith("0x")||to.length!==42)return res.status(400).json({ok:false,error:"Bad recipient"});

    const imageUrl=(typeof pickMerchantImageV2==='function')
  ? await pickMerchantImageV2(BUCKET, merchantName)
  : `https://storage.googleapis.com/${BUCKET}/merchants/dunkin-donuts/images/dunkin-01.png`;

const meta={
  name:`BlockReceipt #${tokenId}`,
  description:`Receipt from ${merchantName}`,
  image:imageUrl,
  external_url:"https://blockreceipt.example",
  attributes:[
    {trait_type:"Merchant",value:merchantName},
    {trait_type:"TotalCents",value:Number(body.totalCents||0)},
    {trait_type:"Timestamp",value:Number(body.timestamp||Math.floor(Date.now()/1000))}
  ]
};

const path=`metadata/${tokenId}.json`;
await bucket.file(path).save(JSON.stringify(meta,null,2),{
  contentType:'application/json',
  resumable:false,
  ifGenerationMatch:0
});
const metaUrl=`https://storage.googleapis.com/${BUCKET}/${path}`;
    const provider=new ethers.providers.JsonRpcProvider(RPC,{chainId:137,name:"polygon"});
    const signer=new ethers.Wallet(PK,provider);
    const abi=['function mint(address to,uint256 id,uint256 amount,bytes data) external'];
    const nft=new ethers.Contract(NFT_ADDR,abi,signer);
    const fd = await provider.getFeeData();

// enforce a minimum tip on Polygon (default 30 gwei unless overridden)
const minTip = ethers.utils.parseUnits(process.env.MIN_TIP_GWEI || "30", "gwei");
const estTip = BigNumber.from(fd.maxPriorityFeePerGas || 0);
const maxPriority = estTip.lt(minTip) ? minTip : estTip;

// base fee: prefer EIP-1559 maxFeePerGas; fallback to legacy gasPrice
const base = BigNumber.from(fd.maxFeePerGas || (await provider.getGasPrice()) || 0);

// headroom: 2x base + tip
const maxFee = base.mul(2).add(maxPriority);

const tx = await nft.mint(to, tokenId, 1, "0x", {
  gasLimit: 220000,
  maxPriorityFeePerGas: maxPriority,
  maxFeePerGas: maxFee
});
    const r=await tx.wait();
    res.json({ok:true,tokenId,to,merchantName,metadata:metaUrl,txHash:tx.hash,blockNumber:r.blockNumber});
  }catch(e){
    console.error(e);
    res.status(500).json({ok:false,error:e?.message||String(e)});
  }
});
const PORT = process.env.PORT || 3000;

app.listen(PORT, () => console.log(`POS webhook listening on :${PORT}`));
